// +build f40_41xxx

// Peripheral: ADC_Common_Periph  Analog to Digital Converter.
// Instances:
//  ADC  mmap.ADC_BASE
// Registers:
//  0x00 32  CSR ADC Common status register.
//  0x04 32  CCR ADC common control register.
//  0x08 32  CDR ADC common regular data register for dual.
// Import:
//  stm32/o/f40_41xxx/mmap
package adc

// DO NOT EDIT THIS FILE. GENERATED BY stm32xgen.

const (
	AWD1   CSR = 0x01 << 0  //+ ADC1 Analog watchdog flag.
	EOC1   CSR = 0x01 << 1  //+ ADC1 End of conversion.
	JEOC1  CSR = 0x01 << 2  //+ ADC1 Injected channel end of conversion.
	JSTRT1 CSR = 0x01 << 3  //+ ADC1 Injected channel Start flag.
	STRT1  CSR = 0x01 << 4  //+ ADC1 Regular channel Start flag.
	OVR1   CSR = 0x01 << 5  //+ ADC1 DMA overrun  flag.
	AWD2   CSR = 0x01 << 8  //+ ADC2 Analog watchdog flag.
	EOC2   CSR = 0x01 << 9  //+ ADC2 End of conversion.
	JEOC2  CSR = 0x01 << 10 //+ ADC2 Injected channel end of conversion.
	JSTRT2 CSR = 0x01 << 11 //+ ADC2 Injected channel Start flag.
	STRT2  CSR = 0x01 << 12 //+ ADC2 Regular channel Start flag.
	OVR2   CSR = 0x01 << 13 //+ ADC2 DMA overrun  flag.
	AWD3   CSR = 0x01 << 16 //+ ADC3 Analog watchdog flag.
	EOC3   CSR = 0x01 << 17 //+ ADC3 End of conversion.
	JEOC3  CSR = 0x01 << 18 //+ ADC3 Injected channel end of conversion.
	JSTRT3 CSR = 0x01 << 19 //+ ADC3 Injected channel Start flag.
	STRT3  CSR = 0x01 << 20 //+ ADC3 Regular channel Start flag.
	OVR3   CSR = 0x01 << 21 //+ ADC3 DMA overrun  flag.
)

const (
	AWD1n   = 0
	EOC1n   = 1
	JEOC1n  = 2
	JSTRT1n = 3
	STRT1n  = 4
	OVR1n   = 5
	AWD2n   = 8
	EOC2n   = 9
	JEOC2n  = 10
	JSTRT2n = 11
	STRT2n  = 12
	OVR2n   = 13
	AWD3n   = 16
	EOC3n   = 17
	JEOC3n  = 18
	JSTRT3n = 19
	STRT3n  = 20
	OVR3n   = 21
)

const (
	MULTI    CCR = 0x1F << 0  //+ MULTI[4:0] bits (Multi-ADC mode selection).
	MULTI_0  CCR = 0x01 << 0  //  Bit 0.
	MULTI_1  CCR = 0x02 << 0  //  Bit 1.
	MULTI_2  CCR = 0x04 << 0  //  Bit 2.
	MULTI_3  CCR = 0x08 << 0  //  Bit 3.
	MULTI_4  CCR = 0x10 << 0  //  Bit 4.
	DELAY    CCR = 0x0F << 8  //+ DELAY[3:0] bits (Delay between 2 sampling phases).
	DELAY_0  CCR = 0x01 << 8  //  Bit 0.
	DELAY_1  CCR = 0x02 << 8  //  Bit 1.
	DELAY_2  CCR = 0x04 << 8  //  Bit 2.
	DELAY_3  CCR = 0x08 << 8  //  Bit 3.
	DDS      CCR = 0x01 << 13 //+ DMA disable selection (Multi-ADC mode).
	DMA      CCR = 0x03 << 14 //+ DMA[1:0] bits (Direct Memory Access mode for multimode).
	DMA_0    CCR = 0x01 << 14 //  Bit 0.
	DMA_1    CCR = 0x02 << 14 //  Bit 1.
	ADCPRE   CCR = 0x03 << 16 //+ ADCPRE[1:0] bits (ADC prescaler).
	ADCPRE_0 CCR = 0x01 << 16 //  Bit 0.
	ADCPRE_1 CCR = 0x02 << 16 //  Bit 1.
	VBATE    CCR = 0x01 << 22 //+ VBAT Enable.
	TSVREFE  CCR = 0x01 << 23 //+ Temperature Sensor and VREFINT Enable.
)

const (
	MULTIn   = 0
	DELAYn   = 8
	DDSn     = 13
	DMAn     = 14
	ADCPREn  = 16
	VBATEn   = 22
	TSVREFEn = 23
)

const (
	DATA1 CDR = 0xFFFF << 0  //+ 1st data of a pair of regular conversions.
	DATA2 CDR = 0xFFFF << 16 //+ 2nd data of a pair of regular conversions.
)

const (
	DATA1n = 0
	DATA2n = 16
)
