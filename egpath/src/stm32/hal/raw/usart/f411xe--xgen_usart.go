// +build f411xe

package usart

// DO NOT EDIT THIS FILE. GENERATED BY xgen.

import (
	"bits"
	"mmio"
	"unsafe"

	"stm32/o/f411xe/mmap"
)

type USART_Periph struct {
	SR   RSR
	DR   RDR
	BRR  RBRR
	CR1  RCR1
	CR2  RCR2
	CR3  RCR3
	GTPR RGTPR
}

func (p *USART_Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

//emgo:const
var USART2 = (*USART_Periph)(unsafe.Pointer(uintptr(mmap.USART2_BASE)))

//emgo:const
var USART1 = (*USART_Periph)(unsafe.Pointer(uintptr(mmap.USART1_BASE)))

//emgo:const
var USART6 = (*USART_Periph)(unsafe.Pointer(uintptr(mmap.USART6_BASE)))

type SR uint32

func (b SR) Field(mask SR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask SR) J(v int) SR {
	return SR(bits.Make32(v, uint32(mask)))
}

type RSR struct{ mmio.U32 }

func (r *RSR) Bits(mask SR) SR      { return SR(r.U32.Bits(uint32(mask))) }
func (r *RSR) StoreBits(mask, b SR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RSR) SetBits(mask SR)      { r.U32.SetBits(uint32(mask)) }
func (r *RSR) ClearBits(mask SR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RSR) Load() SR             { return SR(r.U32.Load()) }
func (r *RSR) Store(b SR)           { r.U32.Store(uint32(b)) }

func (r *RSR) AtomicStoreBits(mask, b SR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RSR) AtomicSetBits(mask SR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RSR) AtomicClearBits(mask SR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMSR struct{ mmio.UM32 }

func (rm RMSR) Load() SR   { return SR(rm.UM32.Load()) }
func (rm RMSR) Store(b SR) { rm.UM32.Store(uint32(b)) }

func (p *USART_Periph) PE() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(PE)}}
}

func (p *USART_Periph) FE() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(FE)}}
}

func (p *USART_Periph) NE() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(NE)}}
}

func (p *USART_Periph) ORE() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(ORE)}}
}

func (p *USART_Periph) IDLE() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(IDLE)}}
}

func (p *USART_Periph) RXNE() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(RXNE)}}
}

func (p *USART_Periph) TC() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(TC)}}
}

func (p *USART_Periph) TXE() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(TXE)}}
}

func (p *USART_Periph) LBD() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(LBD)}}
}

func (p *USART_Periph) CTS() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(CTS)}}
}

type DR uint32

func (b DR) Field(mask DR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask DR) J(v int) DR {
	return DR(bits.Make32(v, uint32(mask)))
}

type RDR struct{ mmio.U32 }

func (r *RDR) Bits(mask DR) DR      { return DR(r.U32.Bits(uint32(mask))) }
func (r *RDR) StoreBits(mask, b DR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RDR) SetBits(mask DR)      { r.U32.SetBits(uint32(mask)) }
func (r *RDR) ClearBits(mask DR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RDR) Load() DR             { return DR(r.U32.Load()) }
func (r *RDR) Store(b DR)           { r.U32.Store(uint32(b)) }

func (r *RDR) AtomicStoreBits(mask, b DR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RDR) AtomicSetBits(mask DR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RDR) AtomicClearBits(mask DR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMDR struct{ mmio.UM32 }

func (rm RMDR) Load() DR   { return DR(rm.UM32.Load()) }
func (rm RMDR) Store(b DR) { rm.UM32.Store(uint32(b)) }

type BRR uint32

func (b BRR) Field(mask BRR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask BRR) J(v int) BRR {
	return BRR(bits.Make32(v, uint32(mask)))
}

type RBRR struct{ mmio.U32 }

func (r *RBRR) Bits(mask BRR) BRR     { return BRR(r.U32.Bits(uint32(mask))) }
func (r *RBRR) StoreBits(mask, b BRR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RBRR) SetBits(mask BRR)      { r.U32.SetBits(uint32(mask)) }
func (r *RBRR) ClearBits(mask BRR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RBRR) Load() BRR             { return BRR(r.U32.Load()) }
func (r *RBRR) Store(b BRR)           { r.U32.Store(uint32(b)) }

func (r *RBRR) AtomicStoreBits(mask, b BRR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RBRR) AtomicSetBits(mask BRR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RBRR) AtomicClearBits(mask BRR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMBRR struct{ mmio.UM32 }

func (rm RMBRR) Load() BRR   { return BRR(rm.UM32.Load()) }
func (rm RMBRR) Store(b BRR) { rm.UM32.Store(uint32(b)) }

func (p *USART_Periph) DIV_Fraction() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(DIV_Fraction)}}
}

func (p *USART_Periph) DIV_Mantissa() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(DIV_Mantissa)}}
}

type CR1 uint32

func (b CR1) Field(mask CR1) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask CR1) J(v int) CR1 {
	return CR1(bits.Make32(v, uint32(mask)))
}

type RCR1 struct{ mmio.U32 }

func (r *RCR1) Bits(mask CR1) CR1     { return CR1(r.U32.Bits(uint32(mask))) }
func (r *RCR1) StoreBits(mask, b CR1) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCR1) SetBits(mask CR1)      { r.U32.SetBits(uint32(mask)) }
func (r *RCR1) ClearBits(mask CR1)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCR1) Load() CR1             { return CR1(r.U32.Load()) }
func (r *RCR1) Store(b CR1)           { r.U32.Store(uint32(b)) }

func (r *RCR1) AtomicStoreBits(mask, b CR1) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RCR1) AtomicSetBits(mask CR1)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RCR1) AtomicClearBits(mask CR1)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMCR1 struct{ mmio.UM32 }

func (rm RMCR1) Load() CR1   { return CR1(rm.UM32.Load()) }
func (rm RMCR1) Store(b CR1) { rm.UM32.Store(uint32(b)) }

func (p *USART_Periph) SBK() RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(SBK)}}
}

func (p *USART_Periph) RWU() RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(RWU)}}
}

func (p *USART_Periph) RE() RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(RE)}}
}

func (p *USART_Periph) TE() RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(TE)}}
}

func (p *USART_Periph) IDLEIE() RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(IDLEIE)}}
}

func (p *USART_Periph) RXNEIE() RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(RXNEIE)}}
}

func (p *USART_Periph) TCIE() RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(TCIE)}}
}

func (p *USART_Periph) TXEIE() RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(TXEIE)}}
}

func (p *USART_Periph) PEIE() RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(PEIE)}}
}

func (p *USART_Periph) PS() RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(PS)}}
}

func (p *USART_Periph) PCE() RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(PCE)}}
}

func (p *USART_Periph) WAKE() RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(WAKE)}}
}

func (p *USART_Periph) M() RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(M)}}
}

func (p *USART_Periph) UE() RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(UE)}}
}

func (p *USART_Periph) OVER8() RMCR1 {
	return RMCR1{mmio.UM32{&p.CR1.U32, uint32(OVER8)}}
}

type CR2 uint32

func (b CR2) Field(mask CR2) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask CR2) J(v int) CR2 {
	return CR2(bits.Make32(v, uint32(mask)))
}

type RCR2 struct{ mmio.U32 }

func (r *RCR2) Bits(mask CR2) CR2     { return CR2(r.U32.Bits(uint32(mask))) }
func (r *RCR2) StoreBits(mask, b CR2) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCR2) SetBits(mask CR2)      { r.U32.SetBits(uint32(mask)) }
func (r *RCR2) ClearBits(mask CR2)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCR2) Load() CR2             { return CR2(r.U32.Load()) }
func (r *RCR2) Store(b CR2)           { r.U32.Store(uint32(b)) }

func (r *RCR2) AtomicStoreBits(mask, b CR2) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RCR2) AtomicSetBits(mask CR2)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RCR2) AtomicClearBits(mask CR2)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMCR2 struct{ mmio.UM32 }

func (rm RMCR2) Load() CR2   { return CR2(rm.UM32.Load()) }
func (rm RMCR2) Store(b CR2) { rm.UM32.Store(uint32(b)) }

func (p *USART_Periph) ADD() RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(ADD)}}
}

func (p *USART_Periph) LBDL() RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(LBDL)}}
}

func (p *USART_Periph) LBDIE() RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(LBDIE)}}
}

func (p *USART_Periph) LBCL() RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(LBCL)}}
}

func (p *USART_Periph) CPHA() RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(CPHA)}}
}

func (p *USART_Periph) CPOL() RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(CPOL)}}
}

func (p *USART_Periph) CLKEN() RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(CLKEN)}}
}

func (p *USART_Periph) STOP() RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(STOP)}}
}

func (p *USART_Periph) LINEN() RMCR2 {
	return RMCR2{mmio.UM32{&p.CR2.U32, uint32(LINEN)}}
}

type CR3 uint32

func (b CR3) Field(mask CR3) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask CR3) J(v int) CR3 {
	return CR3(bits.Make32(v, uint32(mask)))
}

type RCR3 struct{ mmio.U32 }

func (r *RCR3) Bits(mask CR3) CR3     { return CR3(r.U32.Bits(uint32(mask))) }
func (r *RCR3) StoreBits(mask, b CR3) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCR3) SetBits(mask CR3)      { r.U32.SetBits(uint32(mask)) }
func (r *RCR3) ClearBits(mask CR3)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCR3) Load() CR3             { return CR3(r.U32.Load()) }
func (r *RCR3) Store(b CR3)           { r.U32.Store(uint32(b)) }

func (r *RCR3) AtomicStoreBits(mask, b CR3) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RCR3) AtomicSetBits(mask CR3)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RCR3) AtomicClearBits(mask CR3)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMCR3 struct{ mmio.UM32 }

func (rm RMCR3) Load() CR3   { return CR3(rm.UM32.Load()) }
func (rm RMCR3) Store(b CR3) { rm.UM32.Store(uint32(b)) }

func (p *USART_Periph) EIE() RMCR3 {
	return RMCR3{mmio.UM32{&p.CR3.U32, uint32(EIE)}}
}

func (p *USART_Periph) IREN() RMCR3 {
	return RMCR3{mmio.UM32{&p.CR3.U32, uint32(IREN)}}
}

func (p *USART_Periph) IRLP() RMCR3 {
	return RMCR3{mmio.UM32{&p.CR3.U32, uint32(IRLP)}}
}

func (p *USART_Periph) HDSEL() RMCR3 {
	return RMCR3{mmio.UM32{&p.CR3.U32, uint32(HDSEL)}}
}

func (p *USART_Periph) NACK() RMCR3 {
	return RMCR3{mmio.UM32{&p.CR3.U32, uint32(NACK)}}
}

func (p *USART_Periph) SCEN() RMCR3 {
	return RMCR3{mmio.UM32{&p.CR3.U32, uint32(SCEN)}}
}

func (p *USART_Periph) DMAR() RMCR3 {
	return RMCR3{mmio.UM32{&p.CR3.U32, uint32(DMAR)}}
}

func (p *USART_Periph) DMAT() RMCR3 {
	return RMCR3{mmio.UM32{&p.CR3.U32, uint32(DMAT)}}
}

func (p *USART_Periph) RTSE() RMCR3 {
	return RMCR3{mmio.UM32{&p.CR3.U32, uint32(RTSE)}}
}

func (p *USART_Periph) CTSE() RMCR3 {
	return RMCR3{mmio.UM32{&p.CR3.U32, uint32(CTSE)}}
}

func (p *USART_Periph) CTSIE() RMCR3 {
	return RMCR3{mmio.UM32{&p.CR3.U32, uint32(CTSIE)}}
}

func (p *USART_Periph) ONEBIT() RMCR3 {
	return RMCR3{mmio.UM32{&p.CR3.U32, uint32(ONEBIT)}}
}

type GTPR uint32

func (b GTPR) Field(mask GTPR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask GTPR) J(v int) GTPR {
	return GTPR(bits.Make32(v, uint32(mask)))
}

type RGTPR struct{ mmio.U32 }

func (r *RGTPR) Bits(mask GTPR) GTPR    { return GTPR(r.U32.Bits(uint32(mask))) }
func (r *RGTPR) StoreBits(mask, b GTPR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RGTPR) SetBits(mask GTPR)      { r.U32.SetBits(uint32(mask)) }
func (r *RGTPR) ClearBits(mask GTPR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RGTPR) Load() GTPR             { return GTPR(r.U32.Load()) }
func (r *RGTPR) Store(b GTPR)           { r.U32.Store(uint32(b)) }

func (r *RGTPR) AtomicStoreBits(mask, b GTPR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RGTPR) AtomicSetBits(mask GTPR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RGTPR) AtomicClearBits(mask GTPR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMGTPR struct{ mmio.UM32 }

func (rm RMGTPR) Load() GTPR   { return GTPR(rm.UM32.Load()) }
func (rm RMGTPR) Store(b GTPR) { rm.UM32.Store(uint32(b)) }

func (p *USART_Periph) PSC() RMGTPR {
	return RMGTPR{mmio.UM32{&p.GTPR.U32, uint32(PSC)}}
}

func (p *USART_Periph) GT() RMGTPR {
	return RMGTPR{mmio.UM32{&p.GTPR.U32, uint32(GT)}}
}
