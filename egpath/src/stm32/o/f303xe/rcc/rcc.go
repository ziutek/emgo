// Peripheral: RCC_Periph  Reset and Clock Control.
// Instances:
//  RCC  mmap.RCC_BASE
// Registers:
//  0x00 32  CR       Clock control register.
//  0x04 32  CFGR     Clock configuration register.
//  0x08 32  CIR      Clock interrupt register.
//  0x0C 32  APB2RSTR APB2 peripheral reset register.
//  0x10 32  APB1RSTR APB1 peripheral reset register.
//  0x14 32  AHBENR   AHB peripheral clock register.
//  0x18 32  APB2ENR  APB2 peripheral clock enable register.
//  0x1C 32  APB1ENR  APB1 peripheral clock enable register.
//  0x20 32  BDCR     Backup domain control register.
//  0x24 32  CSR      Clock control & status register.
//  0x28 32  AHBRSTR  AHB peripheral reset register.
//  0x2C 32  CFGR2    Clock configuration register 2.
//  0x30 32  CFGR3    Clock configuration register 3.
// Import:
//  stm32/o/f303xe/mmap
package rcc

// DO NOT EDIT THIS FILE. GENERATED BY stm32xgen.

const (
	HSION   CR = 0x01 << 0  //+
	HSIRDY  CR = 0x01 << 1  //+
	HSITRIM CR = 0x1F << 3  //+
	HSICAL  CR = 0xFF << 8  //+
	HSEON   CR = 0x01 << 16 //+
	HSERDY  CR = 0x01 << 17 //+
	HSEBYP  CR = 0x01 << 18 //+
	CSSON   CR = 0x01 << 19 //+
	PLLON   CR = 0x01 << 24 //+
	PLLRDY  CR = 0x01 << 25 //+
)

const (
	HSIONn   = 0
	HSIRDYn  = 1
	HSITRIMn = 3
	HSICALn  = 8
	HSEONn   = 16
	HSERDYn  = 17
	HSEBYPn  = 18
	CSSONn   = 19
	PLLONn   = 24
	PLLRDYn  = 25
)

const (
	SW                       CFGR = 0x03 << 0  //+ SW[1:0] bits (System clock Switch).
	SW_HSI                   CFGR = 0x00 << 0  //  HSI selected as system clock.
	SW_HSE                   CFGR = 0x01 << 0  //  HSE selected as system clock.
	SW_PLL                   CFGR = 0x02 << 0  //  PLL selected as system clock.
	SWS                      CFGR = 0x03 << 2  //+ SWS[1:0] bits (System Clock Switch Status).
	SWS_HSI                  CFGR = 0x00 << 2  //  HSI oscillator used as system clock.
	SWS_HSE                  CFGR = 0x01 << 2  //  HSE oscillator used as system clock.
	SWS_PLL                  CFGR = 0x02 << 2  //  PLL used as system clock.
	HPRE                     CFGR = 0x0F << 4  //+ HPRE[3:0] bits (AHB prescaler).
	HPRE_DIV1                CFGR = 0x00 << 4  //  SYSCLK not divided.
	HPRE_DIV2                CFGR = 0x08 << 4  //  SYSCLK divided by 2.
	HPRE_DIV4                CFGR = 0x09 << 4  //  SYSCLK divided by 4.
	HPRE_DIV8                CFGR = 0x0A << 4  //  SYSCLK divided by 8.
	HPRE_DIV16               CFGR = 0x0B << 4  //  SYSCLK divided by 16.
	HPRE_DIV64               CFGR = 0x0C << 4  //  SYSCLK divided by 64.
	HPRE_DIV128              CFGR = 0x0D << 4  //  SYSCLK divided by 128.
	HPRE_DIV256              CFGR = 0x0E << 4  //  SYSCLK divided by 256.
	HPRE_DIV512              CFGR = 0x0F << 4  //  SYSCLK divided by 512.
	PPRE1                    CFGR = 0x07 << 8  //+ PRE1[2:0] bits (APB1 prescaler).
	PPRE1_DIV1               CFGR = 0x00 << 8  //  HCLK not divided.
	PPRE1_DIV2               CFGR = 0x04 << 8  //  HCLK divided by 2.
	PPRE1_DIV4               CFGR = 0x05 << 8  //  HCLK divided by 4.
	PPRE1_DIV8               CFGR = 0x06 << 8  //  HCLK divided by 8.
	PPRE1_DIV16              CFGR = 0x07 << 8  //  HCLK divided by 16.
	PPRE2                    CFGR = 0x07 << 11 //+ PRE2[2:0] bits (APB2 prescaler).
	PPRE2_DIV1               CFGR = 0x00 << 11 //  HCLK not divided.
	PPRE2_DIV2               CFGR = 0x04 << 11 //  HCLK divided by 2.
	PPRE2_DIV4               CFGR = 0x05 << 11 //  HCLK divided by 4.
	PPRE2_DIV8               CFGR = 0x06 << 11 //  HCLK divided by 8.
	PPRE2_DIV16              CFGR = 0x07 << 11 //  HCLK divided by 16.
	PLLSRC                   CFGR = 0x03 << 15 //+ PLL entry clock source.
	PLLSRC_HSI_PREDIV        CFGR = 0x01 << 15 //  HSI/PREDIV clock as PLL entry clock source.
	PLLSRC_HSE_PREDIV        CFGR = 0x02 << 15 //  HSE/PREDIV clock selected as PLL entry clock source.
	PLLXTPRE                 CFGR = 0x01 << 17 //+ HSE divider for PLL entry.
	PLLXTPRE_HSE_PREDIV_DIV1 CFGR = 0x00 << 17 //  HSE/PREDIV clock not divided for PLL entry.
	PLLXTPRE_HSE_PREDIV_DIV2 CFGR = 0x01 << 17 //  HSE/PREDIV clock divided by 2 for PLL entry.
	PLLMUL                   CFGR = 0x0F << 18 //+ PLLMUL[3:0] bits (PLL multiplication factor).
	PLLMUL2                  CFGR = 0x00 << 18 //  PLL input clock*2.
	PLLMUL3                  CFGR = 0x01 << 18 //  PLL input clock*3.
	PLLMUL4                  CFGR = 0x02 << 18 //  PLL input clock*4.
	PLLMUL5                  CFGR = 0x03 << 18 //  PLL input clock*5.
	PLLMUL6                  CFGR = 0x04 << 18 //  PLL input clock*6.
	PLLMUL7                  CFGR = 0x05 << 18 //  PLL input clock*7.
	PLLMUL8                  CFGR = 0x06 << 18 //  PLL input clock*8.
	PLLMUL9                  CFGR = 0x07 << 18 //  PLL input clock*9.
	PLLMUL10                 CFGR = 0x08 << 18 //  PLL input clock10.
	PLLMUL11                 CFGR = 0x09 << 18 //  PLL input clock*11.
	PLLMUL12                 CFGR = 0x0A << 18 //  PLL input clock*12.
	PLLMUL13                 CFGR = 0x0B << 18 //  PLL input clock*13.
	PLLMUL14                 CFGR = 0x0C << 18 //  PLL input clock*14.
	PLLMUL15                 CFGR = 0x0D << 18 //  PLL input clock*15.
	PLLMUL16                 CFGR = 0x0E << 18 //  PLL input clock*16.
	USBPRE                   CFGR = 0x01 << 22 //+ USB prescaler.
	USBPRE_DIV1_5            CFGR = 0x00 << 22 //  USB prescaler is PLL clock divided by 1.5.
	USBPRE_DIV1              CFGR = 0x01 << 22 //  USB prescaler is PLL clock divided by 1.
	I2SSRC                   CFGR = 0x01 << 23 //+ I2S external clock source selection.
	I2SSRC_SYSCLK            CFGR = 0x00 << 23 //  System clock selected as I2S clock source.
	I2SSRC_EXT               CFGR = 0x01 << 23 //  External clock selected as I2S clock source.
	MCO                      CFGR = 0x07 << 24 //+ MCO[2:0] bits (Microcontroller Clock Output).
	MCO_NOCLOCK              CFGR = 0x00 << 24 //  No clock.
	MCO_LSI                  CFGR = 0x02 << 24 //  LSI clock selected as MCO source.
	MCO_LSE                  CFGR = 0x03 << 24 //  LSE clock selected as MCO source.
	MCO_SYSCLK               CFGR = 0x04 << 24 //  System clock selected as MCO source.
	MCO_HSI                  CFGR = 0x05 << 24 //  HSI clock selected as MCO source.
	MCO_HSE                  CFGR = 0x06 << 24 //  HSE clock selected as MCO source.
	MCO_PLL                  CFGR = 0x07 << 24 //  PLL clock divided by 2 selected as MCO source.
	MCOPRE                   CFGR = 0x07 << 28 //+ MCOPRE[3:0] bits (Microcontroller Clock Output Prescaler).
	MCOPRE_DIV1              CFGR = 0x00 << 28 //  MCO is divided by 1.
	MCOPRE_DIV2              CFGR = 0x01 << 28 //  MCO is divided by 2.
	MCOPRE_DIV4              CFGR = 0x02 << 28 //  MCO is divided by 4.
	MCOPRE_DIV8              CFGR = 0x03 << 28 //  MCO is divided by 8.
	MCOPRE_DIV16             CFGR = 0x04 << 28 //  MCO is divided by 16.
	MCOPRE_DIV32             CFGR = 0x05 << 28 //  MCO is divided by 32.
	MCOPRE_DIV64             CFGR = 0x06 << 28 //  MCO is divided by 64.
	MCOPRE_DIV128            CFGR = 0x07 << 28 //  MCO is divided by 128.
	PLLNODIV                 CFGR = 0x01 << 31 //+ Do not divide PLL to MCO.
)

const (
	SWn       = 0
	SWSn      = 2
	HPREn     = 4
	PPRE1n    = 8
	PPRE2n    = 11
	PLLSRCn   = 15
	PLLXTPREn = 17
	PLLMULn   = 18
	USBPREn   = 22
	I2SSRCn   = 23
	MCOn      = 24
	MCOPREn   = 28
	PLLNODIVn = 31
)

const (
	LSIRDYF  CIR = 0x01 << 0  //+ LSI Ready Interrupt flag.
	LSERDYF  CIR = 0x01 << 1  //+ LSE Ready Interrupt flag.
	HSIRDYF  CIR = 0x01 << 2  //+ HSI Ready Interrupt flag.
	HSERDYF  CIR = 0x01 << 3  //+ HSE Ready Interrupt flag.
	PLLRDYF  CIR = 0x01 << 4  //+ PLL Ready Interrupt flag.
	CSSF     CIR = 0x01 << 7  //+ Clock Security System Interrupt flag.
	LSIRDYIE CIR = 0x01 << 8  //+ LSI Ready Interrupt Enable.
	LSERDYIE CIR = 0x01 << 9  //+ LSE Ready Interrupt Enable.
	HSIRDYIE CIR = 0x01 << 10 //+ HSI Ready Interrupt Enable.
	HSERDYIE CIR = 0x01 << 11 //+ HSE Ready Interrupt Enable.
	PLLRDYIE CIR = 0x01 << 12 //+ PLL Ready Interrupt Enable.
	LSIRDYC  CIR = 0x01 << 16 //+ LSI Ready Interrupt Clear.
	LSERDYC  CIR = 0x01 << 17 //+ LSE Ready Interrupt Clear.
	HSIRDYC  CIR = 0x01 << 18 //+ HSI Ready Interrupt Clear.
	HSERDYC  CIR = 0x01 << 19 //+ HSE Ready Interrupt Clear.
	PLLRDYC  CIR = 0x01 << 20 //+ PLL Ready Interrupt Clear.
	CSSC     CIR = 0x01 << 23 //+ Clock Security System Interrupt Clear.
)

const (
	LSIRDYFn  = 0
	LSERDYFn  = 1
	HSIRDYFn  = 2
	HSERDYFn  = 3
	PLLRDYFn  = 4
	CSSFn     = 7
	LSIRDYIEn = 8
	LSERDYIEn = 9
	HSIRDYIEn = 10
	HSERDYIEn = 11
	PLLRDYIEn = 12
	LSIRDYCn  = 16
	LSERDYCn  = 17
	HSIRDYCn  = 18
	HSERDYCn  = 19
	PLLRDYCn  = 20
	CSSCn     = 23
)

const (
	SYSCFGRST APB2RSTR = 0x01 << 0  //+ SYSCFG reset.
	TIM1RST   APB2RSTR = 0x01 << 11 //+ TIM1 reset.
	SPI1RST   APB2RSTR = 0x01 << 12 //+ SPI1 reset.
	TIM8RST   APB2RSTR = 0x01 << 13 //+ TIM8 reset.
	USART1RST APB2RSTR = 0x01 << 14 //+ USART1 reset.
	SPI4RST   APB2RSTR = 0x01 << 15 //+ SPI4 reset.
	TIM15RST  APB2RSTR = 0x01 << 16 //+ TIM15 reset.
	TIM16RST  APB2RSTR = 0x01 << 17 //+ TIM16 reset.
	TIM17RST  APB2RSTR = 0x01 << 18 //+ TIM17 reset.
	TIM20RST  APB2RSTR = 0x01 << 20 //+ TIM20 reset.
)

const (
	SYSCFGRSTn = 0
	TIM1RSTn   = 11
	SPI1RSTn   = 12
	TIM8RSTn   = 13
	USART1RSTn = 14
	SPI4RSTn   = 15
	TIM15RSTn  = 16
	TIM16RSTn  = 17
	TIM17RSTn  = 18
	TIM20RSTn  = 20
)

const (
	TIM2RST   APB1RSTR = 0x01 << 0  //+ Timer 2 reset.
	TIM3RST   APB1RSTR = 0x01 << 1  //+ Timer 3 reset.
	TIM4RST   APB1RSTR = 0x01 << 2  //+ Timer 4 reset.
	TIM6RST   APB1RSTR = 0x01 << 4  //+ Timer 6 reset.
	TIM7RST   APB1RSTR = 0x01 << 5  //+ Timer 7 reset.
	WWDGRST   APB1RSTR = 0x01 << 11 //+ Window Watchdog reset.
	SPI2RST   APB1RSTR = 0x01 << 14 //+ SPI2 reset.
	SPI3RST   APB1RSTR = 0x01 << 15 //+ SPI3 reset.
	USART2RST APB1RSTR = 0x01 << 17 //+ USART 2 reset.
	USART3RST APB1RSTR = 0x01 << 18 //+ USART 3 reset.
	UART4RST  APB1RSTR = 0x01 << 19 //+ UART 4 reset.
	UART5RST  APB1RSTR = 0x01 << 20 //+ UART 5 reset.
	I2C1RST   APB1RSTR = 0x01 << 21 //+ I2C 1 reset.
	I2C2RST   APB1RSTR = 0x01 << 22 //+ I2C 2 reset.
	USBRST    APB1RSTR = 0x01 << 23 //+ USB reset.
	CANRST    APB1RSTR = 0x01 << 25 //+ CAN reset.
	PWRRST    APB1RSTR = 0x01 << 28 //+ PWR reset.
	DAC1RST   APB1RSTR = 0x01 << 29 //+ DAC 1 reset.
	I2C3RST   APB1RSTR = 0x01 << 30 //+ I2C 3 reset.
)

const (
	TIM2RSTn   = 0
	TIM3RSTn   = 1
	TIM4RSTn   = 2
	TIM6RSTn   = 4
	TIM7RSTn   = 5
	WWDGRSTn   = 11
	SPI2RSTn   = 14
	SPI3RSTn   = 15
	USART2RSTn = 17
	USART3RSTn = 18
	UART4RSTn  = 19
	UART5RSTn  = 20
	I2C1RSTn   = 21
	I2C2RSTn   = 22
	USBRSTn    = 23
	CANRSTn    = 25
	PWRRSTn    = 28
	DAC1RSTn   = 29
	I2C3RSTn   = 30
)

const (
	DMA1EN  AHBENR = 0x01 << 0  //+ DMA1 clock enable.
	DMA2EN  AHBENR = 0x01 << 1  //+ DMA2 clock enable.
	SRAMEN  AHBENR = 0x01 << 2  //+ SRAM interface clock enable.
	FLITFEN AHBENR = 0x01 << 4  //+ FLITF clock enable.
	FMCEN   AHBENR = 0x01 << 5  //+ FMC clock enable.
	CRCEN   AHBENR = 0x01 << 6  //+ CRC clock enable.
	GPIOHEN AHBENR = 0x01 << 16 //+ GPIOH clock enable.
	GPIOAEN AHBENR = 0x01 << 17 //+ GPIOA clock enable.
	GPIOBEN AHBENR = 0x01 << 18 //+ GPIOB clock enable.
	GPIOCEN AHBENR = 0x01 << 19 //+ GPIOC clock enable.
	GPIODEN AHBENR = 0x01 << 20 //+ GPIOD clock enable.
	GPIOEEN AHBENR = 0x01 << 21 //+ GPIOE clock enable.
	GPIOFEN AHBENR = 0x01 << 22 //+ GPIOF clock enable.
	GPIOGEN AHBENR = 0x01 << 23 //+ GPIOG clock enable.
	TSCEN   AHBENR = 0x01 << 24 //+ TS clock enable.
	ADC12EN AHBENR = 0x01 << 28 //+ ADC1/ ADC2 clock enable.
	ADC34EN AHBENR = 0x01 << 29 //+ ADC3/ ADC4 clock enable.
)

const (
	DMA1ENn  = 0
	DMA2ENn  = 1
	SRAMENn  = 2
	FLITFENn = 4
	FMCENn   = 5
	CRCENn   = 6
	GPIOHENn = 16
	GPIOAENn = 17
	GPIOBENn = 18
	GPIOCENn = 19
	GPIODENn = 20
	GPIOEENn = 21
	GPIOFENn = 22
	GPIOGENn = 23
	TSCENn   = 24
	ADC12ENn = 28
	ADC34ENn = 29
)

const (
	SYSCFGEN APB2ENR = 0x01 << 0  //+ SYSCFG clock enable.
	TIM1EN   APB2ENR = 0x01 << 11 //+ TIM1 clock enable.
	SPI1EN   APB2ENR = 0x01 << 12 //+ SPI1 clock enable.
	TIM8EN   APB2ENR = 0x01 << 13 //+ TIM8 clock enable.
	USART1EN APB2ENR = 0x01 << 14 //+ USART1 clock enable.
	SPI4EN   APB2ENR = 0x01 << 15 //+ SPI4 clock enable.
	TIM15EN  APB2ENR = 0x01 << 16 //+ TIM15 clock enable.
	TIM16EN  APB2ENR = 0x01 << 17 //+ TIM16 clock enable.
	TIM17EN  APB2ENR = 0x01 << 18 //+ TIM17 clock enable.
	TIM20EN  APB2ENR = 0x01 << 20 //+ TIM20 clock enable.
)

const (
	SYSCFGENn = 0
	TIM1ENn   = 11
	SPI1ENn   = 12
	TIM8ENn   = 13
	USART1ENn = 14
	SPI4ENn   = 15
	TIM15ENn  = 16
	TIM16ENn  = 17
	TIM17ENn  = 18
	TIM20ENn  = 20
)

const (
	TIM2EN   APB1ENR = 0x01 << 0  //+ Timer 2 clock enable.
	TIM3EN   APB1ENR = 0x01 << 1  //+ Timer 3 clock enable.
	TIM4EN   APB1ENR = 0x01 << 2  //+ Timer 4 clock enable.
	TIM6EN   APB1ENR = 0x01 << 4  //+ Timer 6 clock enable.
	TIM7EN   APB1ENR = 0x01 << 5  //+ Timer 7 clock enable.
	WWDGEN   APB1ENR = 0x01 << 11 //+ Window Watchdog clock enable.
	SPI2EN   APB1ENR = 0x01 << 14 //+ SPI2 clock enable.
	SPI3EN   APB1ENR = 0x01 << 15 //+ SPI3 clock enable.
	USART2EN APB1ENR = 0x01 << 17 //+ USART 2 clock enable.
	USART3EN APB1ENR = 0x01 << 18 //+ USART 3 clock enable.
	UART4EN  APB1ENR = 0x01 << 19 //+ UART 4 clock enable.
	UART5EN  APB1ENR = 0x01 << 20 //+ UART 5 clock enable.
	I2C1EN   APB1ENR = 0x01 << 21 //+ I2C 1 clock enable.
	I2C2EN   APB1ENR = 0x01 << 22 //+ I2C 2 clock enable.
	USBEN    APB1ENR = 0x01 << 23 //+ USB clock enable.
	CANEN    APB1ENR = 0x01 << 25 //+ CAN clock enable.
	PWREN    APB1ENR = 0x01 << 28 //+ PWR clock enable.
	DAC1EN   APB1ENR = 0x01 << 29 //+ DAC 1 clock enable.
	I2C3EN   APB1ENR = 0x01 << 30 //+ I2C 3 clock enable.
)

const (
	TIM2ENn   = 0
	TIM3ENn   = 1
	TIM4ENn   = 2
	TIM6ENn   = 4
	TIM7ENn   = 5
	WWDGENn   = 11
	SPI2ENn   = 14
	SPI3ENn   = 15
	USART2ENn = 17
	USART3ENn = 18
	UART4ENn  = 19
	UART5ENn  = 20
	I2C1ENn   = 21
	I2C2ENn   = 22
	USBENn    = 23
	CANENn    = 25
	PWRENn    = 28
	DAC1ENn   = 29
	I2C3ENn   = 30
)

const (
	LSE            BDCR = 0x07 << 0  //+ External Low Speed oscillator [2:0] bits.
	LSEON          BDCR = 0x01 << 0  //  External Low Speed oscillator enable.
	LSERDY         BDCR = 0x02 << 0  //  External Low Speed oscillator Ready.
	LSEBYP         BDCR = 0x04 << 0  //  External Low Speed oscillator Bypass.
	LSEDRV         BDCR = 0x03 << 3  //+ LSEDRV[1:0] bits (LSE Osc. drive capability).
	RTCSEL         BDCR = 0x03 << 8  //+ RTCSEL[1:0] bits (RTC clock source selection).
	RTCSEL_NOCLOCK BDCR = 0x00 << 8  //  No clock.
	RTCSEL_LSE     BDCR = 0x01 << 8  //  LSE oscillator clock used as RTC clock.
	RTCSEL_LSI     BDCR = 0x02 << 8  //  LSI oscillator clock used as RTC clock.
	RTCSEL_HSE     BDCR = 0x03 << 8  //  HSE oscillator clock divided by 32 used as RTC clock.
	RTCEN          BDCR = 0x01 << 15 //+ RTC clock enable.
	BDRST          BDCR = 0x01 << 16 //+ Backup domain software reset.
)

const (
	LSEn    = 0
	LSEDRVn = 3
	RTCSELn = 8
	RTCENn  = 15
	BDRSTn  = 16
)

const (
	LSION      CSR = 0x01 << 0  //+ Internal Low Speed oscillator enable.
	LSIRDY     CSR = 0x01 << 1  //+ Internal Low Speed oscillator Ready.
	V18PWRRSTF CSR = 0x01 << 23 //+ V1.8 power domain reset flag.
	RMVF       CSR = 0x01 << 24 //+ Remove reset flag.
	OBLRSTF    CSR = 0x01 << 25 //+ OBL reset flag.
	PINRSTF    CSR = 0x01 << 26 //+ PIN reset flag.
	PORRSTF    CSR = 0x01 << 27 //+ POR/PDR reset flag.
	SFTRSTF    CSR = 0x01 << 28 //+ Software Reset flag.
	IWDGRSTF   CSR = 0x01 << 29 //+ Independent Watchdog reset flag.
	WWDGRSTF   CSR = 0x01 << 30 //+ Window watchdog reset flag.
	LPWRRSTF   CSR = 0x01 << 31 //+ Low-Power reset flag.
)

const (
	LSIONn      = 0
	LSIRDYn     = 1
	V18PWRRSTFn = 23
	RMVFn       = 24
	OBLRSTFn    = 25
	PINRSTFn    = 26
	PORRSTFn    = 27
	SFTRSTFn    = 28
	IWDGRSTFn   = 29
	WWDGRSTFn   = 30
	LPWRRSTFn   = 31
)

const (
	FMCRST   AHBRSTR = 0x01 << 5  //+ FMC reset.
	GPIOHRST AHBRSTR = 0x01 << 16 //+ GPIOH reset.
	GPIOARST AHBRSTR = 0x01 << 17 //+ GPIOA reset.
	GPIOBRST AHBRSTR = 0x01 << 18 //+ GPIOB reset.
	GPIOCRST AHBRSTR = 0x01 << 19 //+ GPIOC reset.
	GPIODRST AHBRSTR = 0x01 << 20 //+ GPIOD reset.
	GPIOERST AHBRSTR = 0x01 << 21 //+ GPIOE reset.
	GPIOFRST AHBRSTR = 0x01 << 22 //+ GPIOF reset.
	GPIOGRST AHBRSTR = 0x01 << 23 //+ GPIOG reset.
	TSCRST   AHBRSTR = 0x01 << 24 //+ TSC reset.
	ADC12RST AHBRSTR = 0x01 << 28 //+ ADC1 & ADC2 reset.
	ADC34RST AHBRSTR = 0x01 << 29 //+ ADC3 & ADC4 reset.
)

const (
	FMCRSTn   = 5
	GPIOHRSTn = 16
	GPIOARSTn = 17
	GPIOBRSTn = 18
	GPIOCRSTn = 19
	GPIODRSTn = 20
	GPIOERSTn = 21
	GPIOFRSTn = 22
	GPIOGRSTn = 23
	TSCRSTn   = 24
	ADC12RSTn = 28
	ADC34RSTn = 29
)

const (
	PREDIV          CFGR2 = 0x0F << 0 //+ PREDIV[3:0] bits.
	PREDIV_DIV1     CFGR2 = 0x00 << 0 //  PREDIV input clock not divided.
	PREDIV_DIV2     CFGR2 = 0x01 << 0 //  PREDIV input clock divided by 2.
	PREDIV_DIV3     CFGR2 = 0x02 << 0 //  PREDIV input clock divided by 3.
	PREDIV_DIV4     CFGR2 = 0x03 << 0 //  PREDIV input clock divided by 4.
	PREDIV_DIV5     CFGR2 = 0x04 << 0 //  PREDIV input clock divided by 5.
	PREDIV_DIV6     CFGR2 = 0x05 << 0 //  PREDIV input clock divided by 6.
	PREDIV_DIV7     CFGR2 = 0x06 << 0 //  PREDIV input clock divided by 7.
	PREDIV_DIV8     CFGR2 = 0x07 << 0 //  PREDIV input clock divided by 8.
	PREDIV_DIV9     CFGR2 = 0x08 << 0 //  PREDIV input clock divided by 9.
	PREDIV_DIV10    CFGR2 = 0x09 << 0 //  PREDIV input clock divided by 10.
	PREDIV_DIV11    CFGR2 = 0x0A << 0 //  PREDIV input clock divided by 11.
	PREDIV_DIV12    CFGR2 = 0x0B << 0 //  PREDIV input clock divided by 12.
	PREDIV_DIV13    CFGR2 = 0x0C << 0 //  PREDIV input clock divided by 13.
	PREDIV_DIV14    CFGR2 = 0x0D << 0 //  PREDIV input clock divided by 14.
	PREDIV_DIV15    CFGR2 = 0x0E << 0 //  PREDIV input clock divided by 15.
	PREDIV_DIV16    CFGR2 = 0x0F << 0 //  PREDIV input clock divided by 16.
	ADCPRE12        CFGR2 = 0x1F << 4 //+ ADCPRE12[8:4] bits.
	ADCPRE12_NO     CFGR2 = 0x00 << 4 //  ADC12 clock disabled, ADC12 can use AHB clock.
	ADCPRE12_DIV1   CFGR2 = 0x10 << 4 //  ADC12 PLL clock divided by 1.
	ADCPRE12_DIV2   CFGR2 = 0x11 << 4 //  ADC12 PLL clock divided by 2.
	ADCPRE12_DIV4   CFGR2 = 0x12 << 4 //  ADC12 PLL clock divided by 4.
	ADCPRE12_DIV6   CFGR2 = 0x13 << 4 //  ADC12 PLL clock divided by 6.
	ADCPRE12_DIV8   CFGR2 = 0x14 << 4 //  ADC12 PLL clock divided by 8.
	ADCPRE12_DIV10  CFGR2 = 0x15 << 4 //  ADC12 PLL clock divided by 10.
	ADCPRE12_DIV12  CFGR2 = 0x16 << 4 //  ADC12 PLL clock divided by 12.
	ADCPRE12_DIV16  CFGR2 = 0x17 << 4 //  ADC12 PLL clock divided by 16.
	ADCPRE12_DIV32  CFGR2 = 0x18 << 4 //  ADC12 PLL clock divided by 32.
	ADCPRE12_DIV64  CFGR2 = 0x19 << 4 //  ADC12 PLL clock divided by 64.
	ADCPRE12_DIV128 CFGR2 = 0x1A << 4 //  ADC12 PLL clock divided by 128.
	ADCPRE12_DIV256 CFGR2 = 0x1B << 4 //  ADC12 PLL clock divided by 256.
	ADCPRE34        CFGR2 = 0x1F << 9 //+ ADCPRE34[13:5] bits.
	ADCPRE34_NO     CFGR2 = 0x00 << 9 //  ADC34 clock disabled, ADC34 can use AHB clock.
	ADCPRE34_DIV1   CFGR2 = 0x10 << 9 //  ADC34 PLL clock divided by 1.
	ADCPRE34_DIV2   CFGR2 = 0x11 << 9 //  ADC34 PLL clock divided by 2.
	ADCPRE34_DIV4   CFGR2 = 0x12 << 9 //  ADC34 PLL clock divided by 4.
	ADCPRE34_DIV6   CFGR2 = 0x13 << 9 //  ADC34 PLL clock divided by 6.
	ADCPRE34_DIV8   CFGR2 = 0x14 << 9 //  ADC34 PLL clock divided by 8.
	ADCPRE34_DIV10  CFGR2 = 0x15 << 9 //  ADC34 PLL clock divided by 10.
	ADCPRE34_DIV12  CFGR2 = 0x16 << 9 //  ADC34 PLL clock divided by 12.
	ADCPRE34_DIV16  CFGR2 = 0x17 << 9 //  ADC34 PLL clock divided by 16.
	ADCPRE34_DIV32  CFGR2 = 0x18 << 9 //  ADC34 PLL clock divided by 32.
	ADCPRE34_DIV64  CFGR2 = 0x19 << 9 //  ADC34 PLL clock divided by 64.
	ADCPRE34_DIV128 CFGR2 = 0x1A << 9 //  ADC34 PLL clock divided by 128.
	ADCPRE34_DIV256 CFGR2 = 0x1B << 9 //  ADC34 PLL clock divided by 256.
)

const (
	PREDIVn   = 0
	ADCPRE12n = 4
	ADCPRE34n = 9
)

const (
	USART1SW        CFGR3 = 0x03 << 0  //+ USART1SW[1:0] bits.
	USART1SW_PCLK2  CFGR3 = 0x00 << 0  //  PCLK2 clock used as USART1 clock source.
	USART1SW_SYSCLK CFGR3 = 0x01 << 0  //  System clock selected as USART1 clock source.
	USART1SW_LSE    CFGR3 = 0x02 << 0  //  LSE oscillator clock used as USART1 clock source.
	USART1SW_HSI    CFGR3 = 0x03 << 0  //  HSI oscillator clock used as USART1 clock source.
	I2CSW           CFGR3 = 0x07 << 4  //+ I2CSW bits.
	I2C1SW          CFGR3 = 0x01 << 4  //  I2C1SW bits.
	I2C2SW          CFGR3 = 0x02 << 4  //  I2C2SW bits.
	I2C3SW          CFGR3 = 0x04 << 4  //  I2C3SW bits.
	I2C1SW_HSI      CFGR3 = 0x00 << 4  //  HSI oscillator clock used as I2C1 clock source.
	I2C1SW_SYSCLK   CFGR3 = 0x01 << 4  //  System clock selected as I2C1 clock source.
	I2C2SW_HSI      CFGR3 = 0x00 << 4  //  HSI oscillator clock used as I2C2 clock source.
	I2C2SW_SYSCLK   CFGR3 = 0x02 << 4  //  System clock selected as I2C2 clock source.
	I2C3SW_HSI      CFGR3 = 0x00 << 4  //  HSI oscillator clock used as I2C3 clock source.
	I2C3SW_SYSCLK   CFGR3 = 0x04 << 4  //  System clock selected as I2C3 clock source.
	TIMSW           CFGR3 = 0xAF << 8  //+ TIMSW bits.
	TIM1SW          CFGR3 = 0x01 << 8  //  TIM1SW bits.
	TIM8SW          CFGR3 = 0x02 << 8  //  TIM8SW bits.
	TIM15SW         CFGR3 = 0x04 << 8  //  TIM15SW bits.
	TIM16SW         CFGR3 = 0x08 << 8  //  TIM16SW bits.
	TIM17SW         CFGR3 = 0x20 << 8  //  TIM17SW bits.
	TIM20SW         CFGR3 = 0x80 << 8  //  TIM20SW bits.
	TIM2SW          CFGR3 = 0x01 << 24 //+ TIM2SW bits.
	TIM34SW         CFGR3 = 0x01 << 25 //+ TIM34SW bits.
	TIM1SW_PCLK2    CFGR3 = 0x00 << 25 //  PCLK2 used as TIM1 clock source.
	TIM1SW_PLL      CFGR3 = 0x01 << 8  //  PLL clock used as TIM1 clock source.
	TIM8SW_PCLK2    CFGR3 = 0x00 << 25 //  PCLK2 used as TIM8 clock source.
	TIM8SW_PLL      CFGR3 = 0x02 << 8  //  PLL clock used as TIM8 clock source.
	TIM15SW_PCLK2   CFGR3 = 0x00 << 25 //  PCLK2 used as TIM15 clock source.
	TIM15SW_PLL     CFGR3 = 0x04 << 8  //  PLL clock used as TIM15 clock source.
	TIM16SW_PCLK2   CFGR3 = 0x00 << 25 //  PCLK2 used as TIM16 clock source.
	TIM16SW_PLL     CFGR3 = 0x08 << 8  //  PLL clock used as TIM16 clock source.
	TIM17SW_PCLK2   CFGR3 = 0x00 << 25 //  PCLK2 used as TIM17 clock source.
	TIM17SW_PLL     CFGR3 = 0x20 << 8  //  PLL clock used as TIM17 clock source.
	TIM20SW_PCLK2   CFGR3 = 0x00 << 25 //  PCLK2 used as TIM20 clock source.
	TIM20SW_PLL     CFGR3 = 0x80 << 8  //  PLL clock used as TIM20 clock source.
	USART2SW        CFGR3 = 0x03 << 16 //+ USART2SW[1:0] bits.
	USART2SW_PCLK   CFGR3 = 0x00 << 16 //  PCLK1 clock used as USART2 clock source.
	USART2SW_SYSCLK CFGR3 = 0x01 << 16 //  System clock selected as USART2 clock source.
	USART2SW_LSE    CFGR3 = 0x02 << 16 //  LSE oscillator clock used as USART2 clock source.
	USART2SW_HSI    CFGR3 = 0x03 << 16 //  HSI oscillator clock used as USART2 clock source.
	USART3SW        CFGR3 = 0x03 << 18 //+ USART3SW[1:0] bits.
	USART3SW_PCLK   CFGR3 = 0x00 << 18 //  PCLK1 clock used as USART3 clock source.
	USART3SW_SYSCLK CFGR3 = 0x01 << 18 //  System clock selected as USART3 clock source.
	USART3SW_LSE    CFGR3 = 0x02 << 18 //  LSE oscillator clock used as USART3 clock source.
	USART3SW_HSI    CFGR3 = 0x03 << 18 //  HSI oscillator clock used as USART3 clock source.
	UART4SW         CFGR3 = 0x03 << 20 //+ UART4SW[1:0] bits.
	UART4SW_PCLK    CFGR3 = 0x00 << 20 //  PCLK1 clock used as UART4 clock source.
	UART4SW_SYSCLK  CFGR3 = 0x01 << 20 //  System clock selected as UART4 clock source.
	UART4SW_LSE     CFGR3 = 0x02 << 20 //  LSE oscillator clock used as UART4 clock source.
	UART4SW_HSI     CFGR3 = 0x03 << 20 //  HSI oscillator clock used as UART4 clock source.
	UART5SW         CFGR3 = 0x03 << 22 //+ UART5SW[1:0] bits.
	UART5SW_PCLK    CFGR3 = 0x00 << 22 //  PCLK1 clock used as UART5 clock source.
	UART5SW_SYSCLK  CFGR3 = 0x01 << 22 //  System clock selected as UART5 clock source.
	UART5SW_LSE     CFGR3 = 0x02 << 22 //  LSE oscillator clock used as UART5 clock source.
	UART5SW_HSI     CFGR3 = 0x03 << 22 //  HSI oscillator clock used as UART5 clock source.
	TIM2SW_PCLK1    CFGR3 = 0x00 << 22 //  PCLK1 used as TIM2 clock source.
	TIM2SW_PLL      CFGR3 = 0x01 << 24 //  PLL clock used as TIM2 clock source.
	TIM34SW_PCLK1   CFGR3 = 0x00 << 22 //  PCLK1 used as TIM3/TIM4 clock source.
	TIM34SW_PLL     CFGR3 = 0x01 << 25 //  PLL clock used as TIM3/TIM4 clock source.
)

const (
	USART1SWn = 0
	I2CSWn    = 4
	TIMSWn    = 8
	TIM2SWn   = 24
	TIM34SWn  = 25
	USART2SWn = 16
	USART3SWn = 18
	UART4SWn  = 20
	UART5SWn  = 22
)
